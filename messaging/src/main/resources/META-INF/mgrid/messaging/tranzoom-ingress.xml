<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-xml="http://www.springframework.org/schema/integration/xml"
  xmlns:int-amqp="http://www.springframework.org/schema/integration/amqp"
  xmlns:rabbit="http://www.springframework.org/schema/rabbit"
  xmlns:task="http://www.springframework.org/schema/task"
  xmlns:jmx="http://www.springframework.org/schema/integration/jmx"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/xml http://www.springframework.org/schema/integration/xml/spring-integration-xml.xsd
    http://www.springframework.org/schema/integration/amqp http://www.springframework.org/schema/integration/amqp/spring-integration-amqp.xsd
    http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd
    http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd">
    
    <!--BEGIN-DOT
    
    digraph ingress {
      hl7v3ValidateChannel [shape=cds]
      prepareRoutingChannel [shape=cds]
      toTransformersChannel [shape=cds]
      fhirValidateChannel [shape=cds]
      fhirTransformChannel [shape=cds]
      errorChannel [shape=cds]
      publishErrorChannel [shape=cds]
      
      Broker -> hl7v3ListenerBean
      hl7v3ListenerBean -> hl7v3ValidateChannel
      hl7v3ValidateChannel -> hl7v3Validator
      hl7v3Validator -> prepareRoutingChannel
      
      Broker -> fhirListenerBean
      fhirListenerBean -> fhirValidateChannel
      fhirValidateChannel -> fhirValidator
      fhirValidator -> fhirTransformChannel
      fhirTransformChannel -> fhirTransformer
      fhirTransformer -> prepareRoutingChannel
      
      prepareRoutingChannel -> interactionMapper
      interactionMapper -> toTransformersChannel
      toTransformersChannel -> transformOutboundAdapter
      
      transformOutboundAdapter -> publishResultChannel
      
      errorChannel -> errorHandler
      errorHandler -> publishErrorChannel
      publishErrorChannel -> errorOutboundAdapter
      errorOutboundAdapter -> publishResultChannel
      publishResultChannel -> publishConfirmer
      publishConfirmer -> errorHandler
      
    }
      
    END-DOT-->

  <context:annotation-config/>

  <context:property-placeholder
    location="classpath:META-INF/mgrid/messaging/ingress.properties"
    system-properties-mode="OVERRIDE"/>

  <!-- Channels, routing and transformation -->

  <int:channel id="ingressChannel" />
  <int:channel id="flowControlledChannel" />
  <int:channel id="hl7v3ValidateChannel" />
  <int:channel id="fhirValidateChannel" />
  <int:channel id="publishResultChannel" />
  <int:channel id="prepareRoutingChannel"/>
  <int:channel id="fhirTransformChannel" />

  <!--

  IMPORTANT NOTE!

  All channels which are connected to an outbound-channel-adapter with publisher confirms
  enabled should make sure that the adapter reads messages in a single thread. In general,
  this is true for all code interacting with the same caching connection factory.
  
  Because of the way RabbitMQ implements publisher confirms (set the delivery tag by per-channel counting
  of messages) and the Spring AMQP CachingConnectionFactory implementation sending is not thread-safe at 
  the connection factory level.

  Here we need to attach the publishErrorChannel and toTransformersChannel to the same
  singleTaskExecutor dispatcher, as well as the flowControllerBean which uses the same connection
  factory to query for queue sizes.

  -->

  <int:channel id="publishErrorChannel">
    <int:dispatcher task-executor="singleTaskExecutor" />
  </int:channel>

  <int:channel id="toTransformersChannel">
    <int:dispatcher task-executor="singleTaskExecutor" />
  </int:channel>
  
  <bean id="flowControllerBean" class="net.mgrid.tranzoom.rabbitmq.FlowController">
    <property name="outputChannel" ref="flowControlledChannel"/>
    <property name="queues" value="#{{'transform-hl7v3','transform-sql'}}"/>
    <property name="flowThreshold" value="${config.rabbitmq.tranzoom.flow-threshold}"/>
    <property name="rabbitExecutor" ref="singleTaskExecutor"/>
  </bean>

  <task:executor id="singleTaskExecutor"
    pool-size="1"
    queue-capacity="100"/>

  <!-- Global error channel and handler -->

  <bean id="errorHandler" class="net.mgrid.tranzoom.error.GlobalErrorHandler">
    <property name="publishErrorChannel" ref="publishErrorChannel"/>
  </bean>

  <int:channel id="errorChannel" />

  <int:service-activator
    id="globalErrorHandler"
    input-channel="errorChannel"
    ref="errorHandler" />
    
  <!-- Flow control -->
    
  <task:executor id="flowExecutor" pool-size="1"/>
  <task:scheduler id="flowScheduler" pool-size="1"/>
  
  <task:scheduled-tasks scheduler="flowScheduler">
    <task:scheduled ref="flowControllerBean" method="checkFlow" fixed-delay="${config.rabbitmq.tranzoom.flow-period}"/>
  </task:scheduled-tasks>
  
  <int:service-activator
    id="flowController"
    input-channel="ingressChannel" 
    output-channel="flowControlledChannel"
    ref="flowControllerBean" />

  
    
  <!-- Schema validation

  If XML validation fails we include the source message in the error message.

  We use a custom xml validator instead of the int-xml:validating-filter because we need
  access to both the validation exception and source message.

  -->

  <int:service-activator
    id="hl7v3Validator"
    input-channel="hl7v3ValidateChannel"
    output-channel="prepareRoutingChannel">

    <bean class="net.mgrid.tranzoom.ingress.xml.XmlValidator">
      <property name="selector" ref="hl7v3XmlValidatingMessageSelector"/>
    </bean>
  </int:service-activator>

  <int:service-activator
    id="fhirValidator"
    input-channel="fhirValidateChannel"
    output-channel="fhirTransformChannel">

    <bean class="net.mgrid.tranzoom.ingress.xml.XmlValidator">
      <property name="selector" ref="fhirXmlValidatingMessageSelector"/>
    </bean>
  </int:service-activator>

  <bean id="hl7v3XmlValidatingMessageSelector" class="org.springframework.integration.xml.selector.XmlValidatingMessageSelector">
    <constructor-arg name="schema" value="CDA_R2_NE2010/infrastructure/cda/CDA.xsd"/>
    <constructor-arg name="schemaType" value="http://www.w3.org/2001/XMLSchema"/>
    <property name="throwExceptionOnRejection" value="true"/>
  </bean>

  <bean id="fhirXmlValidatingMessageSelector" class="org.springframework.integration.xml.selector.XmlValidatingMessageSelector">
    <constructor-arg name="schema" value="fhir-xsd/fhir-all.xsd"/>
    <constructor-arg name="schemaType" value="http://www.w3.org/2001/XMLSchema"/>
    <property name="throwExceptionOnRejection" value="true"/>
  </bean>

  <!-- Transform FHIR messages -->

  <int-xml:xslt-transformer
    id="fhirTransformer"
    input-channel="fhirTransformChannel"
    output-channel="prepareRoutingChannel"
    xsl-resource="classpath:fhir-xsl/fhir-v3-transform.xsl"
    result-transformer="resultToSource"/>

  <bean id="resultToSource" class="net.mgrid.tranzoom.ingress.xml.ResultToSourceTransformer" />

  <!-- Prepare message for routing -->

  <int:service-activator
    id="interactionMapper"
    input-channel="prepareRoutingChannel" 
    output-channel="toTransformersChannel">

    <bean class="net.mgrid.tranzoom.ingress.ContentTypeMapper" />
  </int:service-activator>

  <!-- RabbitMQ infrastructure -->
  
  
  
  <!-- We split publisher and consumer connections such that consumers can continue
  if the broker starts blocking connections for flow control.
  
  Note that when a high watermark is hit and all connections are blocked for publishing
  this still starves the consumers because the ingress and xfm components wait for a 
  completed publish (publish confirm) to ack the consumed message and continue.
   -->
  
  <rabbit:connection-factory id="consumeConnectionFactory"
    host="${config.rabbitmq.gateway.host}"
    port="${config.rabbitmq.gateway.port}"
    username="${config.rabbitmq.gateway.user}"
    password="${config.rabbitmq.gateway.password}"
    virtual-host="/gateway"
    publisher-confirms="false"
    publisher-returns="false"/>

  <rabbit:connection-factory id="publishConnectionFactory"
    host="${config.rabbitmq.tranzoom.host}"
    port="${config.rabbitmq.tranzoom.port}"
    username="${config.rabbitmq.tranzoom.user}"
    password="${config.rabbitmq.tranzoom.password}"
    virtual-host="/messaging"
    publisher-confirms="true"
    publisher-returns="false"/>

  <!--
       We cannot use an int-amqp:inbound-channel-adapter because it requires its
       own message listener which does not have access to an AMQP channel, which we
       need to send AMQP acks in manual acknowledge mode (acks are sent after a
       publisher confirm is received from RabbitMQ towards the transformers).
    -->

  <rabbit:listener-container
    connection-factory="consumeConnectionFactory"
    acknowledge="manual"
    concurrency="${config.rabbitmq.gateway.concurrent-consumers}"
    prefetch="${config.rabbitmq.gateway.prefetch-count}">

    <rabbit:listener queue-names="ingress-hl7v3, ingress-fhir" ref="ingressListenerBean"/>
  </rabbit:listener-container>

  <bean id="ingressListenerBean" class="net.mgrid.tranzoom.ingress.IngressListener">
    <property name="outputChannel" ref="ingressChannel"/>
  </bean>
  
  <int:recipient-list-router id="ingressRouter" input-channel="flowControlledChannel">
    <int:recipient channel="hl7v3ValidateChannel" selector-expression="headers['tz-ingress-routingkey'] matches '.*\.hl7v3\..*'"/>
    <int:recipient channel="fhirValidateChannel" selector-expression="headers['tz-ingress-routingkey'] matches '.*\.fhir\..*'"/>
  </int:recipient-list-router>

  <int:service-activator 
    id="publishConfirmer"
    input-channel="publishResultChannel">

    <bean class="net.mgrid.tranzoom.rabbitmq.PublishConfirmListener" />
  </int:service-activator>

  <rabbit:template id="errorTemplate" connection-factory="publishConnectionFactory" />

  <int-amqp:outbound-channel-adapter
    id="errorOutboundAdapter"
    channel="publishErrorChannel"
    amqp-template="errorTemplate"
    exchange-name="errors"
    routing-key="ingress"
    confirm-correlation-expression="headers['tz-source-ref']"
    confirm-ack-channel="publishResultChannel"
    confirm-nack-channel="publishResultChannel"
    />

  <rabbit:template id="transformTemplate" connection-factory="publishConnectionFactory" />

  <int-amqp:outbound-channel-adapter
    id="transformOutboundAdapter"
    channel="toTransformersChannel"
    amqp-template="transformTemplate"
    exchange-name="transform"
    routing-key="hl7v3"
    mapped-request-headers="tz-content-type, tz-ingress-timestamp"
    confirm-correlation-expression="headers['tz-source-ref']"
    confirm-ack-channel="publishResultChannel"
    confirm-nack-channel="publishResultChannel"
    />

</beans>
