<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-amqp="http://www.springframework.org/schema/integration/amqp"
  xmlns:rabbit="http://www.springframework.org/schema/rabbit"
  xmlns:task="http://www.springframework.org/schema/task"
  xmlns:jmx="http://www.springframework.org/schema/integration/jmx"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/amqp http://www.springframework.org/schema/integration/amqp/spring-integration-amqp.xsd
    http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd
    http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd">

  <context:property-placeholder 
    location="classpath:META-INF/mgrid/messaging/ccloader.properties"
    system-properties-mode="OVERRIDE"/>
    
  <context:annotation-config />

  <!-- Channels, routing and transformation -->

  <int:channel id="sqlAggregateChannel"/>
  <int:channel id="toDatabaseChannel"/>
  <int:channel id="failedGroupChannel"/>
  <int:channel id="publishResultChannel"/>
  
  <int:channel id="publishErrorChannel">
    <int:dispatcher task-executor="singleTaskExecutor" />
  </int:channel>
  
  <task:executor id="singleTaskExecutor"
    pool-size="1"
    queue-capacity="100"/>

  <!-- Global error channel and handler -->
  <int:channel id="errorChannel" />
  
  <int:service-activator
    input-channel="errorChannel"
    method="globalError">
    
    <bean class="net.mgrid.tranzoom.error.GlobalErrorHandler" />
  </int:service-activator>

  <!--
    To keep state the aggregator uses an in-memory map by default.
    For the correlation strategy we use a constant expression because in the current implementation
    there is no discrimination between messages (i.e. all belong to the same group).
  -->
  <int:aggregator
    input-channel="sqlAggregateChannel"
    output-channel="toDatabaseChannel"
    message-store="aggregatorStore"
    method="aggregate"
    send-partial-result-on-expiry="true"
    correlation-strategy-expression="1"
    release-strategy-expression="size() == ${config.group-size}"
    expire-groups-upon-completion="true">

    <bean class="net.mgrid.tranzoom.ccloader.AggregatorLogicProcessor" />
  </int:aggregator>

  <bean id="aggregatorStore" class="org.springframework.integration.store.SimpleMessageStore" />

  <bean id="aggregatorReaper" class="org.springframework.integration.store.MessageGroupStoreReaper">
    <property name="messageGroupStore" ref="aggregatorStore"/>
    <property name="timeout" value="${config.group-timeout}"/>
  </bean>

  <task:scheduler id="aggregatorScheduler" pool-size="1" />

  <task:scheduled-tasks scheduler="aggregatorScheduler">
    <task:scheduled ref="aggregatorReaper" method="run" fixed-rate="1000"/>
  </task:scheduled-tasks>

  <int:service-activator
    input-channel="toDatabaseChannel"
    ref="ccloaderDatabaseBean"
    method="loadGroup"
    />

  <int:service-activator
    input-channel="failedGroupChannel"
    ref="ccloaderDatabaseBean"
    method="loadSingle"
    />

  <bean id="ccloaderDatabaseBean" class="net.mgrid.tranzoom.ccloader.Loader">
    <property name="pondUploadScript" value="${config.pond.uploadscript}"/>
    <property name="pondHost" value="${config.pond.dbhost}"/>
    <property name="pondPort" value="${config.pond.dbport}"/>
    <property name="pondDatabase" value="${config.pond.dbname}"/>
    <property name="pondUser" value="${config.pond.dbuser}"/>
    <property name="lakeHost" value="${config.lake.dbhost}"/>
    <property name="lakePort" value="${config.lake.dbport}"/>
    <property name="lakeDatabase" value="${config.lake.dbname}"/>
    <property name="lakeUser" value="${config.lake.dbuser}"/>
    <property name="failedGroupChannel" ref="failedGroupChannel"/>
    <property name="errorChannel" ref="publishErrorChannel"/>
    <property name="confirmListener" ref="publishConfirmListenerBean"/>
    <property name="rabbitConnectionFactory" ref="ccloaderConnectionFactory"/>
  </bean>

  <!-- RabbitMQ infrastructure -->

  <rabbit:connection-factory id="ccloaderConnectionFactory"
    host="${config.rabbitmq.host}"
    port="${config.rabbitmq.port}"
    username="${config.rabbitmq.user}"
    password="${config.rabbitmq.password}"
    virtual-host="/messaging"
    publisher-confirms="true"
    publisher-returns="false"/>

  <task:executor id="inboundTaskExecutor"
    pool-size="${config.pool-size}"
    queue-capacity="100"
    rejection-policy="CALLER_RUNS" />
    
  <!--
       We cannot use an int-amqp:inbound-channel-adapter for the sql messages because it requires its
       own message listener which does not have access to a AMQP channel, which we
       need to send AMQP acks in manual acknowledge mode (acks are sent after a
       publisher confirm is received from RabbitMQ towards the transformers).
    -->

  <rabbit:listener-container
    connection-factory="ccloaderConnectionFactory"
    task-executor="inboundTaskExecutor"
    acknowledge="manual"
    concurrency="${config.rabbitmq.concurrent-consumers}"
    prefetch="${config.rabbitmq.prefetch-count}"
    requeue-rejected="false">

    <rabbit:listener 
      queue-names="transform-sql"
      ref="sqlListenerBean" />
  </rabbit:listener-container>

  <bean id="sqlListenerBean" class="net.mgrid.tranzoom.ccloader.LoaderListener">
    <property name="outputChannel" ref="sqlAggregateChannel"/>
    <property name="errorChannel" ref="publishErrorChannel"/>
  </bean>

  <int:service-activator input-channel="publishResultChannel"
    ref="publishConfirmListenerBean" method="publishResult"/>

  <bean id="publishConfirmListenerBean" class="net.mgrid.tranzoom.rabbitmq.PublishConfirmListener">
    <property name="errorChannel" ref="publishErrorChannel"/>
  </bean>

  <rabbit:template id="errorTemplate" connection-factory="ccloaderConnectionFactory" />

  <int-amqp:outbound-channel-adapter
    channel="publishErrorChannel"
    amqp-template="errorTemplate"
    exchange-name="errors"
    routing-key="sql"
    confirm-correlation-expression="headers['tz-source-ref']"
    confirm-ack-channel="publishResultChannel"
    confirm-nack-channel="publishResultChannel"/>

</beans>
